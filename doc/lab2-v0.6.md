<div align="center">
    <font size="6">实验二 加载 loader</font>
</div>

<div align="center">
    <font size="4">谷建华</font>
</div>
<div align="center">
    <font size="4">2024-09-25 v0.6</font>
</div>

# 实验目的

1. 学习从 boot 加载 loader 的过程
2. 学习 FAT32 文件系统

# 实验预习内容

1. FAT32 的基本格式
2. BIOS 读写硬盘扇区的调用的使用方法
3. 硬盘 LBA 的地址编码

# 实验内容以及步骤

1. 编译构建硬盘启动盘，并挂载到虚拟机上，观察并证实执行流交给了 loader

    (1) 修改 `loader.asm`，使之能够在虚拟机终端中显示 `This is {学生自己的名字的拼音}'s loader`

    (2) 编译 `boot.asm` 和 `loader.asm`，生成相应的二进制文件

    (3) 通过 `dd` 和 `mkfs` 命令制作一个文件镜像盘，挂载到文件夹，将 loader 二进制文件写入文件镜像后，将 boot 写入第 0 个扇区

    (4) 将文件镜像盘作为硬盘启动盘挂载到虚拟机，运行虚拟机观察并记录现象

    注意：对于步骤 1，如果你的名字是张百忍（zhāng'bǎi'rěn），那么你应该显示 `This is zbr's loader`，即拼音首字母小写。

2. 观察并记录文件所使用的簇号，并尝试简单的磁盘读写操作

    (1) 修改 loader 文件，能够像 boot 一样寻找 loader.bin

    (2) 在 loader 中实现打印功能将簇号 **打印在终端**，这需要你自己编写簇号查询方法与打印方法，你不应当且被禁止使用外部工具辅助获取文件簇号并在 loader 中将其直接硬编码打印

    (3) 制作硬盘启动盘，运行虚拟机观察并记录现象

    (4) 创建一个大小为 40KB，名字为 `aA1.txt` 的文件并写入 `disk.img`，修改 loader 使其能够寻找 `aA1.txt` 并打印其 **所有的簇号**，运行虚拟机观察并记录现象

    (5) 在步骤 4 的基础上，在 `aA1.txt` 中填充上任意字符串（保持其大小仍为 40KB），修改 loader 打印该文件的前 10 个字符，验证打印的字符和文件中实际的字符一致

    (6) 在步骤 5 的基础上，修改 loader，将 `aA1.txt` 文件的第 512~515 字节（共 4 字节）修改为 `GOOD`，使用 `mount` 挂载查看镜像或者使用 `xxd` 直接看数据以验证该操作

    注意：步骤 4 可能较难，请好好利用 gdb 调试和 `xxd disk.img | less` 查看镜像数据

3. \[选做] 修复损坏的镜像文件

    (1) 我们准备了一个未知的损坏了的镜像文件 `image/brokon_disk.img`，其文件系统为 FAT32，它的第一张 FAT 表受到了损坏，根目录文件夹中有一个彩蛋，但是它的起始簇号被未知数据覆盖，但万幸的是其余部分均未损坏，你需要根据剩下的信息恢复出文件系统中的数据

    (2) 此实验很磨时间，很难，做的同学需要好好对照 FAT 的官方文档进行学习，需要编写一个 C 程序仔细分析其中的关键信息并一步步恢复，验证你恢复是否成功可以将它用 `mount` 挂载并查看里面的数据，里面有我们准备的彩蛋

    (3) 彩蛋是一个 x86_64 的二进制程序，是可以在 linux 环境下执行的喔

    说明：若做了该部分，将修复后的镜像放在同目录下即可（可能需要使用 `git add --force` 暂存并提交）。

4. 结合参考代码，请尝试自己重写 boot 代码，完成系统引导和加载 loader 的实验

# 实验总结

1. 在 boot 阶段都完成了哪些主要功能？这些功能是如何实现的？如何在引导盘中查找文件 loader.bin 的？
2. 在启动过程中，内存布局是怎样的，请画图表示 loader.bin 运行时的内存布局？

# 实验参考

## 从 boot 到 loader

在上一节成功制作了硬盘启动盘后，实际上 512 字节远远不能满足我们的需求，在进入真正的内核 kernel 之前，要做的东西可不少，加载解析内核文件，进入保护模式，向 BIOS 询问设备信息（比如剩余内存，设备树）等等。因此我们需要一个程序 loader 作为中间缓冲，它不受 512 字节限制。

在有了 loader 之后 boot 的任务一下子就轻松了很多了，它只需要加载 loader，并将执行流交给 loader 即可，仅完成一项工作 512 字节还是能够应付的。

假设我们有了 loader 程序，我们怎么进行加载？要知道在第一个实验里我们的硬盘就只有 512 字节大，往哪里放 loader？

一个简单的想法就是直接将 loader 直接接在 boot 后面，但是这种方式可扩展性极低，无法存放多个文件，文件信息无法很好的管理。

为了解决了这个问题需要一个在磁盘上的持久化的数据结构管理文件信息，上世纪七八十年代微软的工程师设计了 FAT 文件系统，其中 FAT12 是第一代，如果有兴趣可以 [点击此处](https://www.bilibili.com/video/BV1oZ4y1t7ce) 听听 FAT 的历史由来。

利用 FAT 文件系统可以有效管理文件，boot 作为 FAT 文件系统的一部分放进了磁盘第 0 个扇区，然后根据第 0 个扇区的文件系统信息通过 BIOS 中断（分 CHS 和 LBA 两种模式）读取磁盘其余扇区，完成 loader 的加载。

## 系统镜像文件的创建

在编写了 boot 和 loader 两个文件后就需要准备一个镜像文件存放，其中 boot 写入镜像文件的第 0 个扇区，loader 放进文件系统中存放。

在本实验中，你需要创建一个 16MB 的镜像。

通过 `dd` 命令创建镜像文件，创建结束后可以用 `stat` 检查输出镜像的大小。

```shell
# if 读取的文件，这里读取的文件是 zero 抽象文件，这个文件会输出无尽的 0
# of 输出的文件，这里输出的地方是 disk.img 镜像文件
# bs read/write/seek 的块大小
# count 重复多少次读写
dd if=/dev/zero of=disk.img bs=1024 count=16384
```

在创建好镜像文件后，它现在还不是一个 FAT 文件系统，这个可以通过 `file` 命令检查。

在 linux 中有一个命令 `mkfs`，即 make filesystem，可以用来创建文件系统。

```shell
mkfs.vfat -F 32 -s 8 disk.img
```

`vfat` 指定文件系统类型，尽管 FAT 系列有很多，但是根据官方文档，`mkfs` 根据镜像文件的大小判断该是什么类型。对于 1.44MB 的镜像，不追加参数会默认初始化为 FAT12 文件系统。此处分别用 `-F` 和 `-s` 分别指定 FAT 类型和每个簇的扇区数。

在创建完文件系统后就该考虑怎么把 loader 放进去了，镜像文件可以通过 `mount` 命令进行挂载，挂载到一个文件夹之后，所有对镜像文件的操作可以抽象成对该文件夹的操作，所以可以通过 `cp` 命令将 loader 写入镜像文件。

```shell
sudo mount disk.img /mnt -o loop # 将挂载到 /mnt 文件夹
sudo cp loader.bin /mnt          # 将 loader 拷贝过去后文件镜像里就写入了 loader 的数据
sudo umount /mnt                 # 解除挂载，如果失败的话需要多执行几次
```

> 以上命令中 `mount` 命令需要请求 sudo 权限，其中挂载到 /mnt 仅提供参考，在 Makefile 中提供了更安全的挂载方式，可自行查看。

将 loader 写入文件镜像后最后一步就要将 boot 写入第 0 个扇区。

```shell
# conv=notrunc 取消截断，防止镜像被置为写后的 512 字节
dd if=boot.bin of=disk.img bs=512 count=1 conv=notrunc
```

> 以上命令仅说明如何将 boot.bin 写入镜像，实际上由于 fat32 在第一个扇区保留了 fs 的元信息，故 boot.bin 的写入位置和写入大小应当稍作调整以避免覆盖了 fs 的相关信息。
>
> 具体写入方法可以在 Makefile 中找到。

这样 `disk.img` 就可以当做硬盘启动盘，放进 qemu 虚拟机模拟运行了，挂载运行的方法与 lab1 一致。

## 关于段寄存器

料想可得，这应该是你第一次大面积地、频繁地接触段寄存器，无关实模式与否。

你会在 boot.asm 中见到对各种段寄存器的赋值和使用，也会面临突然需要赋值若干段寄存器的情况。

你或许明白段寄存器的作用，但这也未必会妨碍你完全摸不清楚它们各自的使用情景。

在实验中，你会接触到总计 6 个段寄存器，它们分别是：

| 寄存器 |     说明     |
| :----: | :----------: |
|   cs   | 代码段寄存器 |
|   ds   | 数据段寄存器 |
|   ss   | 堆栈段寄存器 |
|   es   | 附加段寄存器 |
|   fs   | 附加段寄存器 |
|   gs   | 附加段寄存器 |

**实模式** 中关于段寄存器需要注意的事项，用简单几句话概括就是：

1. cs 是代码寻址的段寄存器，如转移指令的目的地址将根据该寄存器进行寻址
2. ds 是数据访存的默认段寄存器，当数据访存未显式指定段时，默认使用该寄存器进行寻址
3. ss 是堆栈操作的段寄存器，使用 push、pop 等指令时将按照该寄存器进行寻址
4. 附加段寄存器的核心是 **附加**，即额外的，也即在有必要的情况下，你可以自由使用它们来达成你的需求
5. 除了前 3 条提及的外，其余部分指令也会隐式地依靠一组特定的寄存器进行操作，如 rep 系列将使用 es:di 与 ds:si，mul div 指令会使用 dx:ax 等，它们不局限于使用段寄存器，故在处理你不熟悉的指令时，务必优先弄清楚该指令的行为
6. 将硬性规范除外，你应当具备始终将自己的的意图和思路保留在高优先级的意识，你可以在 **合适** 的范围内 **自由** 地规划你能够利用的一切；在必要之时，cs 未必一定要用来寻址代码段，ss 也未必始终用来操作堆栈，当它们并非处在触之即死的情况下，你完全可以让它们稍稍擅离职守，用来解决你诸如段“寄存器不够用了之类”的燃眉之急——请注意，在这段话中，**合适** 是极其关键的，你不应当滥用它们，也不应当在它应当遵守约定的时机仍然使其脱离应有的语义

不过，当你在 lab3 中进入到保护模式后，情况会产生些微妙的变化，就不应当再过分随意了。

一方面，你主动编写的汇编会开始和 C 由编译器生成的代码打交道，而编译器总是会假定一系列约定以生成稳定可靠亦或是高效的代码，若是你在执行流中随意修改任意寄存器，那么便破坏了编译器所生成的代码的假定条件，如此便会有极极极极大可能导致整个程序崩盘。

另一方面，段寄存器不再存储段基址，而是段选择子之类的东东，同时访存也会通过开启的分页机制进行，变得复杂的访存机制使得修改段寄存器值不再是一件唾手可及或可以随心所欲的事情。

## 磁盘扇区的读写

在 boot 加载 loader 的过程中读取磁盘是靠着 13h 中断命令，通过中断让 BIOS 将磁盘中的数据读到内存中，读取方式有 CHS（柱面/磁头/扇区）和 LBA（Logical Block Addressing）两种。

对于 CHS 读取方式，读取一个扇区需要经过复杂的运算，包括柱面、磁道、扇区。

在本实验中，使用了更简单的 LBA 读取方式，它只需要读入的逻辑扇区号就可以直接将磁盘上的文件读入。

LBA 读入方式使用的是 BIOS 的 13h 扩展读功能，功能标识号为 0x42。

LBA 最核心的是要往里面传入一个结构体参数，写成 C 语言的 struct 类似长这样：

```c
struct buffer_packet {
    uint8_t packet_size;
    uint8_t reserved;
    uint16_t total_sectors;
    uint32_t buffer;
    uint64_t start_sector;
    void *l_buffer;
};
```

- `packet_size` 传入结构体的字节数，取值为 0x10 或 0x18，区别在于最后一个字段 `l_buffer` 是否启用
- `reserved` 保留字段，总是为 0
- `total_sectors` 总共需要连续读取的扇区数
- `buffer` 接受磁盘数据的缓冲区地址，按段与偏移寻址，其中高 2 字节为段寄存器值，低 2 字节为偏移量，当 `packet_size` 为 0x10 时有效，无效时需要置为 0xffffffff
- `start_sector` 从第几个逻辑扇区开始读入（起始扇区 LBA），低 48 位有效，高 16 位为 0
- `l_buffer` 接受磁盘数据的缓冲区地址，当 `packet_size` 为 0x18 时有效

调用 int 13h 中断时的寄存器参数设置如下：

- **ah** 功能号 0x42
- **dl** 目标驱动号
- **ds:si** 指向 `buffer_packet` 结构体的指针地址

> 本实验中仅挂载 disk.img 一块硬盘，对应为 0 号硬盘即 0x80。
>
> 在 boot 的参考代码中，简单起见，硬编码了 0x80 作为目标驱动号。
>
> 如果你想要更稳健些，也可以在进入 boot 时获取并存储 dl 寄存器的值，它是由 BIOS 在引导时自动设置的当前驱动器号。

通过调用 int 13h 将数据从持久化设备（磁盘）中读入到内存中，这样可以完成数据的加载。

至于如何向磁盘中写入数据，需要你自行学习，幸运的是，这和读取数据差别不大。

如果你希望使用终端产生指定长度的随机字符串，这里给出一些提示，你可以用这些命令组合出你想要的功能：

- 虚拟设备 `/dev/urandom` 可以不断地产生随机字节流。
- `tr` 命令用于转换或删除文件中的字符。例如，`tr -dc '0-9'` 可以选择输入字符串中的数字输出。
- `fold` 命令用于限制文件列宽。例如，`fold -w 32` 可以将一个长字符串按照每行最多 32 个字符输出。
- `head` 命令可用于查看文件的开头部分的内容。例如，`head -c 100` 可以查看文件的前 100 个字符。

> 当然，这在 Makefile 中也已经提供。
>
> 顺带一提，从 lab2 开始，提供的 Makefile 的复杂度可能会比较高或很高，类似的写法将一致延续到最终的大实验，不过比较幸运的是，它们都比较完整、健全、好用，其中的一些具体操作十分值得学习。

## 修复文件系统

修复文件系统说简单也简单，说难也难，如果不熟悉文件系统的话学习成本会比较搞。

在之前的实验，我们使用的是文件系统功能的子集，而修复文件系统需要知道它的全集，要不然从哪里修复都不知道，博客基本上是无法把所有东西讲清楚，所以看文档是最有效的方法。

当你脑中有一个设计知道怎么去做的时候，你又会发现第二个难题——你的实现能力跟不上了。在你们大学的前几年，可能说自己做了几个项目，但是实际情况上是用高级语言调用几个 API 就可以完成，难度在于建模，以及怎么跟数据打交道，并没有对底层有过太多的交互。

大部分情况下我们都是在做计算型的编程，只要运算出来输出就完事了，而这次你需要独自面对系统，Python 这种高级语言可能会给你帮倒忙，因为它不太适合处理这种情况。

你所能做的就只有拿着 C/C++，以及一堆由 glibc（比如 printf，puts 这些常用函数）包装好的 API 与内核进行交互。

虽然同样是 API，glibc 的 API 相当的底层，需要 `man` 命令好好阅读相关函数调用的细节。

不要惧怕英文，靠自己查博客绝对会把自己查晕，实现半天发现函数干的跟自己想的不一样。

在你们实现中会遇到另一个可怕的事情就是 `struct` 结构体，C++ 中类似的问题或许不甚被关注，但在 C 中，请务必注意内存对齐的问题，如果你直接实现的话可能会惊喜地发现实际的结构体跟你想的并不那么一致。

> 不是语言不行，是你不懂语言（划掉）

在实现时推荐大家使用一种防御性编程 `assert(expr)`，就是当 expr 表达式的值为 false 时程序会及时奔溃并告诉你奔溃的位置。

如果不想让自己的程序出太多离谱的错还要花大量时间尝试，就应该使用这种方式，在各种你觉得可能会出问题的地方加上一个 `assert`。

如果你通过一步步翻文档，一步步独立调错终于把镜像文件给恢复正确，你就能够看到我们准备的 **彩蛋**，这给你的成就感（也可能是惊吓）会相当的大。

如果会读手册并且具备一定的实现能力，你大概就能发现你能干更多事，即便是那些看上去很难的程序实际上你也能够不算太折磨地实现。
