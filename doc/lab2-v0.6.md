<div align="center">
    <font size="6">实验二 加载 loader</font>
</div>

<div align="center">
    <font size="4">谷建华</font>
</div>
<div align="center">
    <font size="4">2024-09-25 v0.6</font>
</div>

# 实验目的

1. 学习从 boot 加载 loader 的过程
2. 学习 FAT32 文件系统

# 实验预习内容

1. FAT32 的基本格式
2. BIOS 读写硬盘扇区的调用的使用方法
3. 硬盘 LBA 的地址编码

# 实验内容以及步骤

1. 编译构建硬盘启动盘，并挂载到虚拟机上，观察并证实执行流交给了 loader

    (1) 修改 `loader.asm`，使之能够在虚拟机终端中显示 `This is {学生自己的名字的拼音}'s loader`

    (2) 编译 `boot.asm` 和 `loader.asm`，生成相应的二进制文件

    (3) 通过 `dd` 和 `mkfs` 命令制作一个文件镜像盘，挂载到文件夹，将 loader 二进制文件写入文件镜像后，将 boot 写入第 0 个扇区

    (4) 将文件镜像盘作为硬盘启动盘挂载到虚拟机，运行虚拟机观察并记录现象

    注意：对于步骤 1，如果你的名字是张百忍（zhāng'bǎi'rěn），那么你应该显示 `This is zbr's loader`，即拼音首字母小写。

2. 观察并记录文件所使用的簇号，并尝试简单的磁盘读写操作

    (1) 修改 loader 文件，能够像 boot 一样寻找 loader.bin

    (2) 在 loader 中编写打印功能将簇号 **打印在终端**，这需要你自己编写簇号查询方法与打印方法，你不应当且被禁止使用外部工具辅助获取文件簇号并在 loader 中将其直接硬编码打印

    (3) 制作硬盘启动盘，运行虚拟机观察并记录现象

    (4) 创建一个大小为 40KB，名字为 `aA1.txt` 的文件并写入 `disk.img`，修改 loader 寻找 `aA1.txt` 并打印其 **所有的簇号**，运行虚拟机观察并记录现象

    (5) 在步骤 4 的基础上，将 `aA1.txt` 中填充上任意字符串（保持其大小仍为 40KB），修改 loader 打印该文件的前 10 个字符，验证打印的字符和文件中实际的字符一致

    (6) 在步骤 5 的基础上，修改 loader，将 `aA1.txt` 文件的第 512~515 字节（共 4 字节）处修改为 `GOOD`，使用 `mount` 挂载查看镜像或者使用 `xxd` 直接看数据以验证该操作

    注意：步骤 3 可能较难，请好好利用 gdb 调试和 `xxd disk.img | less` 查看镜像数据

3. \[选做] 修复损坏的镜像文件

    (1) 我们准备了一个未知的损坏了的镜像文件 `image/brokon_disk.img`，其文件系统为 FAT32，它的第一张 FAT 表受到了损坏，根目录文件夹中有一个彩蛋，但是它的起始簇号被未知数据覆盖，但万幸的是其余部分均未损坏，你需要根据剩下的信息恢复出文件系统中的数据

    (2) 此实验很磨时间，很难，做的同学需要好好对照 FAT 的官方文档进行学习，需要编写一个 C 程序仔细分析其中的关键信息并一步步恢复，验证你恢复是否成功可以将它用 `mount` 挂载并查看里面的数据，里面有我们准备的彩蛋

    (3) 彩蛋是一个 x86_64 的二进制程序，是可以在 linux 环境下执行的喔

    说明：若做了该部分，将修复后的镜像放在同目录下即可（可能需要使用 `git add --force` 暂存并提交）。

4. 结合参考代码，请尝试自己重写 boot 代码，完成系统引导和加载 loader 的实验

# 实验总结

1. 在 boot 阶段都完成了哪些主要功能？这些功能是如何实现的？如何在引导盘中查找文件 loader.bin 的？
2. 在启动过程中，内存布局是怎样的，请画图表示 loader.bin 运行时的内存布局？

# 实验参考

## 从 boot 到 loader

在上一节成功制作了硬盘启动盘后，实际上 512 字节远远不能满足我们的需求，在进入真正的内核 kernel 之前，要做的东西可不少，加载解析内核文件，进入保护模式，向 BIOS 询问设备信息（比如剩余内存，设备树）等等。因此我们需要一个程序 loader 作为中间缓冲，它不受 512 字节限制。

在有了 loader 之后 boot 的任务一下子就轻松了很多了，它只需要加载 loader，并将执行流交给 loader 即可，仅完成一项工作 512 字节还是能够应付的。

假设我们有了 loader 程序，我们怎么进行加载？要知道在第一个实验里我们的硬盘就只有 512 字节大，往哪里放 loader？

一个简单的想法就是直接将 loader 直接接在 boot 后面，但是这种方式可扩展性极低，无法存放多个文件，文件信息无法很好的管理。

为了解决了这个问题需要一个在磁盘上的持久化的数据结构管理文件信息，上世纪七八十年代微软的工程师设计了 FAT 文件系统，其中 FAT12 是第一代，如果有兴趣可以 [点击此处](https://www.bilibili.com/video/BV1oZ4y1t7ce) 听听 FAT 的历史由来。

利用 FAT 文件系统可以有效管理文件，boot 作为 FAT 文件系统的一部分放进了磁盘第 0 个扇区，然后根据第 0 个扇区的文件系统信息通过 BIOS 中断（分 CHS 和 LBA 两种模式）读取磁盘其余扇区，完成 loader 的加载。

## 系统镜像文件的创建

在编写了 boot 和 loader 两个文件后就需要准备一个镜像文件存放，其中 boot 写入镜像文件的第 0 个扇区，loader 放进文件系统中存放。

在本实验中，你需要创建一个 16MB 的镜像。

通过 `dd` 命令创建镜像文件，创建结束后可以用 `stat` 检查输出镜像的大小。

```shell
# if 读取的文件，这里读取的文件是 zero 抽象文件，这个文件会输出无尽的 0
# of 输出的文件，这里输出的地方是 disk.img 镜像文件
# bs read/write/seek 的块大小
# count 重复多少次读写
dd if=/dev/zero of=disk.img bs=1024 count=16384
```

在创建好镜像文件后，它现在还不是一个 FAT 文件系统，这个可以通过 `file` 命令检查。

在 linux 中有一个命令 `mkfs`，即 make filesystem，可以用来创建文件系统。

```shell
mkfs.vfat -F 32 -s 8 disk.img
```

`vfat` 指定文件系统类型，尽管 FAT 系列有很多，但是根据官方文档，`mkfs` 根据镜像文件的大小判断该是什么类型。对于 1.44MB 的镜像，不追加参数会默认初始化为 FAT12 文件系统。此处分别用 `-F` 和 `-s` 分别指定 FAT 类型和每个簇的扇区数。

在创建完文件系统后就该考虑怎么把 loader 放进去了，镜像文件可以通过 `mount` 命令进行挂载，挂载到一个文件夹之后，所有对镜像文件的操作可以抽象成对该文件夹的操作，所以可以通过 `cp` 命令将 loader 写入镜像文件。

```shell
sudo mount disk.img /mnt -o loop # 将挂载到 /mnt 文件夹
sudo cp loader.bin /mnt          # 将 loader 拷贝过去后文件镜像里就写入了 loader 的数据
sudo umount /mnt                 # 解除挂载，如果失败的话需要多执行几次
```

> 以上命令中 `mount` 命令需要请求 sudo 权限，其中挂载到 /mnt 仅提供参考，在 Makefile 中提供了更安全的挂载方式，可自行查看。

将 loader 写入文件镜像后最后一步就要将 boot 写入第 0 个扇区。

```shell
# conv=notrunc 取消截断，防止镜像被置为写后的 512 字节
dd if=boot.bin of=disk.img bs=512 count=1 conv=notrunc
```

> 以上命令仅说明如何将 boot.bin 写入镜像，实际上由于 fat32 在第一个扇区保留了 fs 的元信息，故 boot.bin 的写入位置和写入大小应当稍作调整以避免覆盖了 fs 的相关信息。
>
> 具体写入方法可以在 Makefile 中找到。

这样 `disk.img` 就可以当做硬盘启动盘，放进 qemu 虚拟机模拟运行了，挂载运行的方法与 lab1 一致。

## 磁盘扇区的读写

在 boot 加载 loader 的过程中读取磁盘是靠着 13h 中断命令，通过中断让 BIOS 将磁盘中的数据读到内存中，读取方式有 CHS（柱面/磁头/扇区）和 LBA（Logical Block Addressing）两种。

对于 CHS 读取方式，读取一个扇区需要经过复杂的运算，包括柱面、磁道、扇区。

在本实验中，使用了更简单的 LBA 读取方式，它只需要读入的逻辑扇区号就可以直接将磁盘上的文件读入。

LBA 读入方式使用的是 BIOS 的 13h 扩展读功能，功能标识号为 0x42。

LBA 最核心的是要往里面传入一个结构体参数，写成 C 语言的 struct 类似长这样：

```c
struct buffer_packet {
    uint8_t packet_size;
    uint8_t reserved;
    uint16_t total_sectors;
    uint32_t buffer;
    uint64_t start_sector;
    void *l_buffer;
};
```

- `packet_size` 传入结构体的字节数，取值为 0x10 或 0x18，区别在于最后一个字段 `l_buffer` 是否启用
- `reserved` 保留字段，总是为 0
- `total_sectors` 总共需要连续读取的扇区数
- `buffer` 接受磁盘数据的缓冲区地址，按段与偏移寻址，其中高 2 字节为段寄存器值，低 2 字节为偏移量，当 `packet_size` 为 0x10 时有效，无效时需要置为 0xffffffff
- `start_sector` 从第几个逻辑扇区开始读入（起始扇区 LBA），低 48 位有效，高 16 位为 0
- `l_buffer` 接受磁盘数据的缓冲区地址，当 `packet_size` 为 0x18 时有效

调用 int 13h 中断时的寄存器参数设置如下：

- **ah** 功能号 0x42
- **dl** 目标驱动号
- **ds:si** 指向 `buffer_packet` 结构体的指针地址

> 本实验中仅挂载 disk.img 一块硬盘，对应为 0 号硬盘即 0x80。
>
> 在 boot 的参考代码中，简单起见，硬编码了 0x80 作为目标驱动号。
>
> 如果你想要更稳健些，也可以在进入 boot 时获取并存储 dl 寄存器的值，它是由 BIOS 在引导时自动设置的当前驱动器号。

通过调用 int 13h 将数据从持久化设备（磁盘）中读入到内存中，这样可以完成数据的加载。

至于如何向磁盘中写入数据，需要你自行学习，幸运的是，这和读取数据差别不大。

如果你希望使用终端产生指定长度的随机字符串，这里给出一些提示，你可以用这些命令组合出你想要的功能：

- 虚拟设备 `/dev/urandom` 可以不断地产生随机字节流。
- `tr` 命令用于转换或删除文件中的字符。例如，`tr -dc '0-9'` 可以选择输入字符串中的数字输出。
- `fold` 命令用于限制文件列宽。例如，`fold -w 32` 可以将一个长字符串按照每行最多 32 个字符输出。
- `head` 命令可用于查看文件的开头部分的内容。例如，`head -c 100` 可以查看文件的前 100 个字符。

> 当然，这在 Makefile 中也已经提供。
>
> 顺带一提，从 lab2 开始，提供的 Makefile 的复杂度可能会比较高或很高，类似的写法将一致延续到最终的大实验，不过比较幸运的是，它们都比较完整、健全、好用，其中的一些具体操作十分值得学习。

## 修复文件系统

修复文件系统说简单也简单，说难也难，如果不熟悉文件系统的话学习成本会比较搞。

在之前的实验，我们使用的是文件系统功能的子集，而修复文件系统需要知道它的全集，要不然从哪里修复都不知道，博客基本上是无法把所有东西讲清楚，所以看文档是最有效的方法。

当你脑中有一个设计知道怎么去做的时候，你又会发现第二个难题——你的实现能力跟不上了。在你们大学的前几年，可能说自己做了几个项目，但是实际情况上是用高级语言调用几个 API 就可以完成，难度在于建模，以及怎么跟数据打交道，并没有对底层有过太多的交互。

大部分情况下我们都是在做计算型的编程，只要运算出来输出就完事了，而这次你需要独自面对系统，Python 这种高级语言可能会给你帮倒忙，因为它不太适合处理这种情况。

你所能做的就只有拿着 C/C++，以及一堆由 glibc（比如 printf，puts 这些常用函数）包装好的 API 与内核进行交互。

虽然同样是 API，glibc 的 API 相当的底层，需要 `man` 命令好好阅读相关函数调用的细节。

不要惧怕英文，靠自己查博客绝对会把自己查晕，实现半天发现函数干的跟自己想的不一样。

在你们实现中会遇到另一个可怕的事情就是 `struct` 结构体，C++ 中类似的问题或许不甚被关注，但在 C 中，请务必注意内存对齐的问题，如果你直接实现的话可能会惊喜地发现实际的结构体跟你想的并不那么一致。

> 不是语言不行，是你不懂语言（划掉）

在实现时推荐大家使用一种防御性编程 `assert(expr)`，就是当 expr 表达式的值为 false 时程序会及时奔溃并告诉你奔溃的位置。

如果不想让自己的程序出太多离谱的错还要花大量时间尝试，就应该使用这种方式，在各种你觉得可能会出问题的地方加上一个 `assert`。

如果你通过一步步翻文档，一步步独立调错终于把镜像文件给恢复正确，你就能够看到我们准备的 **彩蛋**，这给你的成就感（也可能是惊吓）会相当的大。

如果会读手册并且具备一定的实现能力，你大概就能发现你能干更多事，即便是那些看上去很难的程序实际上你也能够不算太折磨地实现。
