<div align="center">
    <font size="6"> 实验一 操作系统引导 </font>
</div>

<div align="center">
    <font size="4"> 谷建华 </font>
</div>
<div align="center">
    <font size="4"> 2024-09-18 v0.6 </font>
</div>

# 实验目的

1. 学习创建 qemu 虚拟机
2. 学习使用 gdb 调试 qemu 虚拟机
3. 学习使用 make 工程构建和管理工具
4. 学习启动引导原理和过程

# 实验预习内容

1. 完成实验开发工具的安装
2. 了解 gdb 的基本功能、make 的基本用途
3. 了解操作系统引导的基本过程

# 实验内容以及步骤

1. 制作硬盘启动盘在 qemu 虚拟机上加载启动

    (1) 结合实验参考中的 `int 10h` 相关文档，补全 boot.asm 中 TODO 部分的代码，使其能够显示 BootMessage 指定的信息

    (2) 编译 boot 程序，生成二进制文件

    (3) 创建虚拟机并挂载二进制文件作为硬盘，查看并记录运行结果

    注意：在该步骤中，请勿修改 BootMessage 的内容

2. 制作一个能够在虚拟机终端中显示 `This is {学生自己的名字的拼音}'s boot` 的启动引导盘

    (1) 修改 boot 程序，重新编译

    (2) 制作硬盘启动盘，在虚拟机上加载启动，查看并记录结果

3. 在步骤 2 的基础上，依次实现下面功能：

    (1) 清除屏幕上所有字符

    (2) 然后在第 19 行第 38 处显示蓝底白色字符串 `NWPU`

    (3) 最后让光标置于 10 行 10 列处

    (4) 制作硬盘启动盘，在虚拟机上加载启动，查看并记录结果

4. 查出 `err_boot.asm` 启动引导程序的问题

    (1) 迁移步骤 3 中 boot.asm 的补全部分到 err_boot.asm 中

    (2) 制作硬盘启动盘，在虚拟机上加载启动，查看并记录结果

    (3) 发现代码存在的问题，并改正之

5. 编写 Makefile 文件，要求实现以下功能：

    (1) 输入命令 `make` 能够实现从 `boot.asm` 编译成 `boot.bin`

    (2) 根据 `boot.asm` 和 `boot.bin` 的创建时间先后分别做两次实验 `make`，观察 `make` 执行情况并记录

    (3) 输入命令 `make clean` 实现 `boot.bin` 的删除

    (4) 输入命令 `make run` 实现虚拟机的快速创建

    提示：本实验操作过程中会覆盖之前的代码及实验结果，或许你可以考虑设计一下 Makefile 使其能够指定执行的实验步骤，例如 `make run TARGET=2` 演示步骤 2 的实验结果，而 `make run TARGET=3` 演示步骤 3 的实验结果。

6. \[选做] 修改 qemu 虚拟机的启动项，让虚拟机从 USB 上启动（通过虚拟机的 BIOS 设置实现）

    (1) 修改 boot 的显示为 `boot from USB`

    (2) 编译 boot 程序并作成 USB 启动盘，在虚拟机上加载启动，查看并记录结果

    注意：USB 可能需要格式化成 FAT12 或 FAT16 格式

7. \[选做] 真机从 USB 启动

    (1) 在一个真实的 USB 盘上制作成一个启动盘

    (2) 把一台物理机设置为从 USB 盘启动（通过修改 BIOS 设置实现），在物理机上插上 USB 盘，加电启动该物理机，查看并记录结果

> 选做内容不会对你的分数有任何影响，仅提供一个实验方向供感兴趣的同学尝试。

# 实验总结

1. 试说明从计算机加电后，到引导程序的第一条指令被运行的过程？
2. boot 程序中在显示器上显示字符串的功能是如何完成的？
3. 结合 gdb 调试信息，给出进入 BIOS 中第一条指令的地址？触发 int 10h 中断后第一条指令的地址？

# 实验参考

## 启动引导

在 x86 类型的计算机启动的时候，即摁下电源开关时，系统会首先运行固件程序 firmware。

固件程序由硬件厂商已经硬编码好的，在此次实验环境下是 bios 程序，bios 会按某种顺序遍历所有可能的硬件存储设备（软驱/硬盘/光盘）寻找启动引导设备。

启动引导设备需要满足的要求是它的第 0 个扇区（一般是 0 柱面、0 磁道、0 扇区，一个扇区有 512 字节）的最后两个字节数据为 `0xaa55`（硬件厂商规定）。

如果 bios 发现一个设备满足启动引导设备要求，则会将该设备的第 0 个扇区加载到内存中的 `0:0x7c00` 处，最后将 pc 跳至 `0:0x7c00`，将执行流交给引导程序.也就是说，广义上讲，我们的操作系统的第一条指令就是在 `0:0x7c00`。

## 创建 boot 镜像

此次实验通过 qemu 虚拟机完成，虚拟机可以简单理解为模拟真实硬件环境的软件，在使用虚拟模拟硬件环境之前，我们需要先准备一个启动引导（以下称为 boot）设备。

准备 boot 设备需要先编写一个 boot 程序，文件夹下的 `boot.asm` 存储的是启动引导的汇编源代码，通过下列命令可以将它编译成二进制文件:

```shell
nasm boot.asm -o boot.bin
```

在编译完后 `boot.bin` 就是大小为一个扇区（512B）的 boot 程序，可以通过以下命令验证：

```shell
file ./boot.bin # 验证文件类型
stat ./boot.bin # 验证文件大小
```

## 创建 qemu 虚拟机

在写完 boot 程序后，这个程序本身就可以作为一个镜像文件挂在到虚拟机上，通过以下命令可以运行虚拟机并把 boot.bin 挂载到硬盘上：

```shell
qemu-system-i386                    \ # 运行的虚拟机环境为i386
    -boot order=c                   \ # 运行的时候首先检查硬盘有没有启动引导程序
    -drive file=boot.bin,format=raw   # 抽象 boot.bin 成为一个硬盘设备，模拟挂在到虚拟环境中
```

> make 使用 sh 为默认 shell，该 sh 链接到 bash
>
> 在 bash 中，可以使用 \ 输入多行命令

输入命令就能看到图形化的界面弹出，并按照预期打印一个字符串。

## 在 qemu 虚拟机里使用 gdb

为了能够让启动过程细化，我们还支持了对虚拟机的 gdb 调试，命令如下：

```shell
# -S 让指令停在 bios 程序的第一条指令，为了能够让 gdb 操作
# -s 让虚拟机开放 1234 端口供 gdb 调试（数据通过本地回环网络 tcp 传输）
qemu-system-i386                    \
    -boot order=c                   \
    -drive file=boot.bin,format=raw \
    -S -s
```

```shell
# -ex 在进入 gdb 的时候自动填入命令，减少手工输入的时间
# set tdesc filename target.xml
# 由于 boot 程序运行环境为 16 位，默认情况下 gdb 不能支持 16 位指令的解析，需要导入 xml 文件让解析正常
# xml 文件在同文件夹下
# target remote localhost: 1234
# 让 gdb 连接 1234 端口用于开始调试
gdb -ex 'set tdesc filename target.xml' \
    -ex 'target remote localhost:1234'
```

开启两个终端，一个用于开启虚拟机，另一个用于开启 gdb，就能通过 gdb 调试虚拟机。

**关于提供给 gdb 的 xml 文件**

i386-32bit.xml 具体指定了目标架构中的寄存器信息供 gdb 解析使用。

target.xml 引用 i386-32bit.xml 文件并描述目标架构，即这里的 16 位 i8086。

如果你对这个内容感兴趣，请参考 GDB 文档中的 Target Description Format 第一节。

[参考文档](https://astralvx.com/debugging-16-bit-in-qemu-with-gdb-on-windows/)

## int 10h 中断

[参考: BIOS 中断表](http://www.ctyme.com/intr/int.htm)

10h 号中断是一个实模式显示服务，在本实验中，可能会用到以下功能：

|  AH   |     功能     |
| :---: | :----------: |
|  02h  | 改变光标位置 |
|  06h  | 屏幕向上滚动 |
|  13h  |  输出字符串  |

13h 功能 bl 寄存器的字符属性取值表：

| 颜色码 |  颜色  | 颜色码 |   颜色   |
| :----: | :----: | :----: | :------: |
| 0000b  |  黑色  | 1000b  |   灰色   |
| 0001b  |  蓝色  | 1001b  |  淡蓝色  |
| 0010b  |  绿色  | 1010b  |  淡绿色  |
| 0011b  |  青色  | 1000b  |  淡青色  |
| 0100b  |  红色  | 1100b  |  淡红色  |
| 0101b  | 紫红色 | 1101b  | 淡紫红色 |
| 0110b  |  棕色  | 1110b  |   黄色   |
| 0111b  |  银色  | 1111b  |   白色   |

> 高两位为背景色，低两位为前景色
