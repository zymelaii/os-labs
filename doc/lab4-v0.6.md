<div align="center">
    <font size="6">实验四 中断</font>
</div>

<div align="center">
    <font size="4">谷建华</font>
</div>
<div align="center">
    <font size="4">2024-10-20 v0.6</font>
</div>

# 实验目的

1. 学习中断描述符与中断处理全流程（特别是执行流、堆栈、权限的切换），包括中断描述符表 IDT 的功能和设置
2. 学习时钟中断和键盘中断的处理过程
3. 学习分时任务调度

# 实验预习内容

1. 中断描述表 IDT
2. 8259A 设置外设中断
3. 分时任务调度原理
4. 键盘中断的字模的获取和处理

# 实验内容以及步骤

1. 验证时钟中断的发生

    (1) 编译运行基准代码，观察并分析现象

    (2) 修改时钟中断处理程序，使之从输出 `#` 变成输出 `ik`，重新构建运行，观察并分析现象

    (3) 修改 `kernel_main`，实现向进程传递执行参数：修改进程表的初始化过程，向测试函数 `TestABC` 传递参数（具体格式参考函数定义与提供的注释），并将进程表中的 `TestA` `TestB` `TestC` 替换为 3 个`TestABC` 进程，测试实现是否正确，你应当能够得到不同颜色的输出

    说明：对于步骤 2，输出 `ik` 中的 `k` 代表某数字，也即你的输出应当是类似 `i1i2i3` 的以 `ik` 的格式输出的序列

    提示: 参考正常的函数调用是如何传递参数的，可以看看文档仓库里面的 `x86-32bit-ccc-chapter.pdf` 来回忆一下相关内容，最终的任务实现需要模拟这个过程并正确设置相关的寄存器

2. 修改时钟中断触发时的调度机制，让某个进程被分配到更少的时间片，从而达成进程饥饿的目的，编译运行后观察并分析现象

    注意：进程必须得活着的能够输出，饥饿不等于杀掉进程

3. 修改硬件时钟频率，使之大约以 1000Hz 的频率触发时钟中断，编译运行后观察证实你新修改的频率要比原来的快（这个频率很难测量，只能通过对比的方式估计）

	提示：你需要设置 8253 PIT timer0 的状态以实现该操作，详情可见 [OSDev Wiki | PIT](https://wiki.osdev.org/Programmable_Interval_Timer)

4. 阅读 Orange 第 7 章内容并结合实验参考，添加键盘中断

    (1) 使之能够正确识别 `a`\~`z`，其余字符全部丢弃，识别出来的字符通过调用 `keyboard.c` 中的 `kb_put_key` 函数将字符添加到字符缓冲区中（需学生自行实现该函数）

    (2) 修改 `keyboard.c` 中的 `getch` 函数，这是一个非阻塞的函数，即当缓冲区非空时，将缓冲区队头字符弹出，并返回该字符，当缓冲区中没有字符时，返回 0xff

    (3) 有了时钟中断和键盘中断就能做一个小游戏了，代码框架中提供了一个贪吃蛇程序，修改时钟频率至 1000Hz，删除时钟中断处理函数中的所有 `kprintf`，在 `kernel_main` 中仅创建一个单进程，进程入口函数会在 `gameplay.h` 中给出，最后重新编译 kernel 就可以游玩了（这一步不用写进报告）

	说明：对于步骤 1，你不需要处理任何修饰键，例如对于 Shift，如果你得到了 `Shift+a`，你应当将其输出为 `a` 而不是 `A`

# 实验总结

1. 操作系统内核的初始化阶段都完成哪些主要功能？
2. 刚刚进入时钟中断处理程序时系统用的是哪个堆栈，中断号是多少？执行流在哪个位置？在执行中断服务程序的过程中堆栈发生哪些变化？`call [irq_table + 4 * %2]` 的功能是什么？
3. 外设（时钟、键盘等）中断的中断号是由谁决定的？在哪里决定的？
4. 在中断处理程序中，为什么需要执行开中断或关中断指令?

# 实验参考

## 说明

在前几个实验，我们一直是在内核态，而我们的进程一般都是在用户态下执行的，这样进程即便做出出格的事情也不会伤到内核。

那么接下来需要研究 `kernel_main` 函数是怎么进入用户态。

这次实验的重点是从 `restart` 函数出发进入到用户态，然后又因为中断回到内核态这一整个过程。

在这个实验中，用户态和内核态分别对应 x86 架构中的特权级 RING3 和 RING0。

## 中断初始化

### 如何区分当前执行流为用户态和内核态

平时都说用户态，内核态，但是怎么区分执行流目前的状态靠的就是段寄存器，可以发现段描述符的大小刚好是 8 字节，所以存储在段寄存器中的段选择子值假设是 $x$，那么 $\lfloor\frac{x}{8}\rfloor$ 就能够描述选择的是第几个段，即在二进制角度看段选择子的低三位就没有被用上，所以硬件工程师就考虑把这些位利用上，第 0\~1 位用于权限，第 2 位用于标识段是全局段还是局部段。

对于权限的划分各位需要阅读 Orange 教材，这里不细展开，总之靠着段选择子的第 0~1 位可以划分当前段的权限，当权限为用户态时，执行流就是用户态。

### LDT 初始化

LDT 全称局部描述符表，跟 GDT 很类似，需要 LDT 是因为在之前可能不同的任务它们的段寄存器可能会不同。

为了区分，每个任务有它自己的独一套 LDT，这样切换不同任务时标识更容易些。

虽然理论上每个任务都有自己的独一套 LDT，但都是 $2^{32}$ 寻址，限制都是靠分页做的（相关内容将在下一个实验出现），所以我们只需要加载一次 ldt 就能满足所有用户态进程的需求。

为了方便大家理解段之间的区别，这里我们约定 GDT 里面全是存储内核态会用到的段描述符（除了显存段），LDT 里面存储用户态会用到的段描述符。

```C
//! 初始化 ldt 段描述符
init_segment(&gdt[5]，(u32)ldt，sizeof(ldt) - 1，DA_LDT);
//! 在加载了 gdt 后，ldt 就可以通过传入段选择子的方法加载
lgdt [gdt_ptr]      ; 使用新的 GDT
lldt [SELECTOR_LDT] ; SELECTOR_LDT = 0x28 = 40 = 5 * 8
```

### 中断

这一次实验我们要开始处理中断了，平时课上也讲过，执行流在用户态的时候肯定不能放心一直将执行流交给用户态，例如用户不能关中断 IF 位，要不然就永远无法响应中断了。

以时钟中断为例，每次执行固定时长后硬件会向内核发送一次中断，在触发中断异常/用户请求系统调用的时候能够回到内核态，不同的触发方式会执行不同的处理函数，那么如何区分这些不同的触发方式就需要 IDT 了。

### IDT 初始化

IDT 中断描述符表会根据中断的形式决定进入内核的中断处理函数，而区分形式是靠中断号判断，根据中断号找到对应的门描述符，根据中断描述符找到对应的中断处理函数入口和加载对应的 CS 段寄存器，将执行流交给内核。

类似 gdt，idt 需要通过 `lidt` 命令将 idt 表的数据结构载入，该数据结构与上一个实验的 `gdt_ptr` 一致。

```nasm
lidt [idt_ptr]
```

### 8259A 初始化

8259A 简单来说是外设中断的实际处理硬件，时钟中断，键盘中断，鼠标中断等都是靠它给内核发送信号触发中断，它也需要初始化与中断描述符之间的联系。

## 中断处理过程

### 进入用户态

在内核中，每个进程需要维护一个用于存放进程用户态当前状态的寄存器表，当用户态因为某些原因陷入内核态时用户态的当前所有寄存器信息就存放在寄存器表中，当从内核态又回到用户态时就根据寄存器表恢复用户态当前的状态。

```C
typedef struct stack_frame_s {
  u32 gs;          //<! ━┓
  u32 fs;          //<!  ┃
  u32 es;          //<!  ┃
  u32 ds;          //<!  ┃
  u32 edi;         //<!  ┃
  u32 esi;         //<!  ┣━┫ push by `save`
  u32 ebp;         //<!  ┃
  u32 kernel_esp;  //<!  ┣ ignored by popad
  u32 ebx;         //<!  ┃
  u32 edx;         //<!  ┃
  u32 ecx;         //<!  ┃
  u32 eax;         //<! ━┫
  u32 retaddr;     //<!  ┣ retaddr for `save`
  u32 eip;         //<! ━┫
  u32 cs;          //<!  ┃
  u32 eflags;      //<!  ┣━┫ push by interrupt
  u32 esp;         //<!  ┃
  u32 ss;          //<! ━┛
} stack_frame_t;
```

这个就是我们这个实验会用到寄存器表，`gs` 在低地址，`ss` 在高地址，接下来结合源码分析进入用户态这个过程中寄存器的变化。

在 `kernel_main` 中，我们需要对寄存器做一次初始化：

```c
proc->regs.cs = cs_sel;
proc->regs.ds = ds_sel;
proc->regs.es = ds_sel;
proc->regs.fs = ds_sel;
proc->regs.ss = ds_sel;
proc->regs.gs = gs_sel;

proc->regs.eip = (u32)entry[i];
stack_ptr += DEFAULT_STACK_SIZE;
proc->regs.esp = (u32)stack_ptr;
proc->pid = i + 1;
proc->regs.eflags = EFLAGS_RESERVED | EFLAGS_IF | EFLAGS_IOPL(1);
```

这里可以看到初始化的段寄存器中除了 `gs` 都有 `SA_TIL` 标志位，它的实际值是 4，即二进制意义下的第 2 位，标志着这个段是选择的是 ldt 中的段，而 ldt 中的段都是用户态权限的，所以在进入到用户态时执行流权限就自动切换到用户态。

再之后就是 eip，这是执行流的寄存器，esp 用于分配栈，eflags 用于初始化 flags 信息。

在 `kernel_main` 初始化完后会调用 `restart` 函数进入用户态，这是一个汇编接口函数，关键的代码如下：

```nasm
restart:
	mov	esp, [p_proc_ready]
	lea	eax, [esp + P_STACKTOP]
	mov	dword [tss + TSS3_S_SP0], eax

; 我们的代码从这里开始分析，上面的等下会讲
restart_reenter:
	cli
	dec	dword [k_reenter]
	pop	gs
	pop	fs
	pop	es
	pop	ds
	popad
	add	esp, 4
	iretd
```

先是关中断，我们肯定不希望在恢复用户态寄存器信息时被意外的中断干扰，再接下来是 `k_reenter` 减 1（自行阅读源码），之后开始恢复寄存器信息。

在寄存器恢复步骤，先是恢复 `gs`\~`ds` 一共四个段寄存器信息。再是恢复 `edi`\~`eax` 这八个寄存器。

需要注意的是 `kernel_esp` 比较特殊，它实际上不起恢复作用，因为现在的 `esp` 还不是用户态 `esp`，而且 `popad` 指令会略过 `esp` 的恢复。

再这之后，是 `esp` 加 4 跳过 `retaddr`（这个变量是用于 `save` 这个函数，它存储的是 `call save` 时 `ret` 的地址），最后调用 `iret` 将 `eip`\~`ss` 这五个寄存器恢复（让这五个寄存器单独用特殊指令恢复的原因是这五个与执行流密切相关），由于 eflags 中 IF 位被置 1 中断被重新打开。

### 返回内核态

执行流肯定不能一直留在用户态，在接受中断的时候需要再次陷入内核态。

再次陷入内核态后，硬件保证了在进入中断时 eflags 的中断 IF 位为 0，不会受到其余中断的影响，这个时候内核调用了 `call` 函数保存 `eax`\~`gs` 寄存器（关于为什么不保存 `ss`\~`eip` 这五个寄存器的答案将在下一小节说明）：

```nasm
save:
    pushad                      ; `.
    push    ds                  ;  |
    push    es                  ;  | 保存原寄存器值
    push    fs                  ;  |
    push    gs                  ; /

    mov     dx, ss
    mov     ds, dx
    mov     es, dx

    mov     eax, esp            ; eax = 进程表起始地址

    inc     dword [k_reenter]             ; ++k_reenter;
    cmp     dword [k_reenter], 0          ; if (k_reenter == 0)
    jne     .1                            ; {
    mov     esp, StackTop                 ;   mov esp, StackTop
    push    restart                       ;   push restart
    jmp     [eax + RETADR - P_STACKBASE]  ;   return
.1:                                       ; } else {
    push    restart_reenter               ;   push restart_reenter
    jmp     [eax + RETADR - P_STACKBASE]  ;   return
                                          ; }
```

在进入 `call` 函数中，`ret` 的返回地址被存入了寄存器表中 `retaddr` 的位置，然后调用了 `pushad` 将 `eax`\~`edi` 存入寄存器表中，最后将其余段寄存器存入表中。

需要注意的是这段代码最后的两个 `jmp`，虽然我们的语义是从 `save` 函数返回，但是这个时候不能直接用 `ret` 指令，因为 `ret` 指令会自动将栈顶作为返回地址使用。

而中断处理程序则需要（详情见 [重新进入用户态](#重新进入用户态)）我们将栈顶设置为 `restart` 或 `restart_reenter`。

也就是说，此时的栈顶并不是 `save` 函数的返回地址，否则 `ret` 的话会返回到错误的地址。

因此，使用 `jmp` 直接跳转到寄存器表中的 `retaddr` 指向的地址，使得栈一直保持我们想要的构造。

### 屏蔽中断和置 EOI

```nasm
in      al, INT_M_CTLMASK    ; `.
or      al, (1 << %2)        ;  | 屏蔽当前中断
out     INT_M_CTLMASK, al    ; /
mov     al, EOI              ; `. 置EOI位
out     INT_M_CTL, al        ; /
sti                          ; CPU在响应中断的过程中会自动关中断，这句之后就允许响应新的中断
```

在保存完寄存器后，需要修改中断掩码使得不再响应相同类型的中断，保证在内核中不会被同类中断干扰。

然后，需要向 `INT_M_CTL` 端口发送 EOI 信号，告诉硬件已经做好准备了，可以接受下一个中断了，否则的话有可能在 `sti` 之后马上又被下一个中断打扰。

EOI 信号指的是 `End Of Interrupt`，由于多个设备可以请求处理器的注意，因此处理器需要决定如何响应这些请求，以及哪个中断应该被优先处理，这就需要 CPU 和中断控制器协同工作。

发送 EOI 信号是为了通知中断控制器，CPU 已经处理完了特定中断请求，从而允许中断控制器按照特定的优先级规则，继续处理其他中断请求。

### 重新进入用户态

再接下来就是中断处理程序的调用了，在处理完中断后就可以准备返回用户态了：

```nasm
cli
in  al, INT_M_CTLMASK ; `.
and al, ~(1 << %1)    ;  | 恢复接受当前中断
out INT_M_CTLMASK, al ; /
ret
```

跟上节做的事情（修改中断掩码使得不再响应相同类型的中断）相反，这里重新恢复接受这个类型的中断，然后使用 `ret` 指令。

还记得 `save` 函数里面的 `push restart` 和 `push restart_reenter` 两个指令吗？

这个 `push` 的地址值就是为了 `ret` 准备的，`ret` 过后会重新回到 `restart`，然后最终回到用户态。

## TSS 机制

TSS 书上写的很玄乎，很难理解，但是实际上 TSS 没有那么难，举个实例就可以很清晰的知道 TSS 的作用。

假设我们在用户态执行的程序突然受到一个中断要返回内核态，那么这个时候肯定不能就着用户态的 esp 存储寄存器信息，需要切换到一个特定的栈（内核栈）存储寄存器信息，那么这个内核栈的 ss 和 esp 需要预先存储到一个特定地方用于进入内核态时切换——

没错，需要段寄存器，因为用户的段寄存器是低权限的，如果访问内核栈会违反保护模式，QEMU 在检测到之后会直接重新启动，观察到的结果则是终端不断闪现 boot 信息——

而这个存放的位置就是 TSS，TSS 里面存放很多数据，看起来很吓人，但是实际上现在我们只会使用其中的 `ss0` 和 `esp0`（0 指代 ring0 内核权限级）。

当从用户态进入到内核态时，ss 和 esp 会切换内核态的对应寄存器，这个时候就能正常执行内核程序。

TSS 是一个段，存放在 gdt 表中（标识为 `DA_386TSS`），下面是 gdt 表中 TSS 段的初始化的示例：

```c
tss.ss0 = SELECTOR_FLAT_RW;	//<! ss0 的初始化在这里完成
tss.iobase = sizeof(tss);	//<! 没有 I/O 许可位图
init_segment(&gdt[4], (u32)&tss, sizeof(tss) - 1, DA_386TSS);
```

在初始化完 TSS 段之后需要通过 `ltr` 加载 TSS 选择子让硬件知晓 TSS 段。

```nasm
_start:
    mov     esp, StackTop

    call    cstart

    lgdt    [gdt_ptr]           ; load new gdt
    mov     ax, SELECTOR_LDT
    lldt    ax                  ; load ldt
    mov     ax, SELECTOR_TSS
    ltr     ax                  ; load tss
    lidt    [idt_ptr]           ; load idt

    ; use a long jmp to activate the new gdt immediately
    jmp     SELECTOR_KERNEL_CS:cinit
```

在每次调用 `restart` 函数的时候，将 TSS 中的 `sp0` 寄存器赋值为进程存储的寄存器表的顶部地址，对应保存 `ss` 寄存器的内存位置（参考前述的寄存器表的内容），保证进入内核态之后第一个压入的寄存器的值对应的是寄存器表中的 `ss`。

当再次陷入内核态时，首先将 TSS 中的 `esp0` 和 `ss0` 赋值到 `esp` 和 `ss` 寄存器，再之后 `eip`\~`ss` 这五个寄存器会被压入栈中。

其中，`esp` 和 `ss` 是用户态下的，虽然从逻辑上感觉不可思议，但是硬件总是可行的。

```nasm
restart:
	mov	esp, [p_proc_ready]
	lea	eax, [esp + P_STACKTOP]
	mov	dword [tss + TSS3_S_SP0], eax
restart_reenter:
	...
```

## 时钟中断

时钟中断反正也挺简单的，Orange 书上也有写，也就一个固定频率的晶振电路，触发指定次后向 OS 发送一个中断信号，这个时候执行流需要陷入内核然后处理时钟中断处理程序。

## 键盘中断

这又是书上讲的很玄乎的一部分，但是实际上没那么玄乎，实验用不到那么多。

在接受到键盘中断后，我们实际上只需要解决三个问题：

如何获取键盘输入的扫描码？

如何将扫描码解析成正常 ASCII 码字符？

解析后的 ASCII 码字符怎么用？

从键盘输入上获取扫描码这个问题比较简单书上也讲了，存储在标号为 `0x60` 的端口里，可以通过 inb 指令/方法从端口的值读取一字节。

如果不及时读出来，你再怎么摁键盘也不会触发键盘中断——这可以理解为第一次输入的扫描码直接把端口霸占住了，不让其他扫描码进来。

但是实际上我们读入的是扫描码，是键盘上的一种编码，而我们需要将这种编码进行再一步映射将扫描码映射成我们熟悉的 ASCII 字符。

我们从端口里读入的是一个字节的数据，能表达 0\~255 之间的数，而 ASCII 字符仅能表达 0\~127 之间的数。

最高位没有被用到，所以被硬件工程师重新利用。要知道我们摁下键盘实际上分摁下和弹起两个操作，对于同一个字符，它摁下与弹起的扫描码的区别在于摁下是最高位置 0，而弹起是最高位置 1，如果一直摁下会一直发送摁下的扫描码。

对于 `a`\~`z` 这些字符，我们摁一次键会收到两个扫描码（摁下和弹起），但是在我们的日常理解里我们只关心摁下这个操作，所以在这次实验中，我们需要忽略掉弹起的扫描码，只关心摁下的扫描码，接下来需要解决的就是一个映射问题，`keymap.h` 里存放着一张扫描码到 ASCII 码的转换表，通过这张转换表就可以直接将扫描码转化为 ASCII 字符，这里并不需要考虑 shift，ctrl 这种特殊的控制字符，只需要实现实验要求的功能即可。

在获取完 ASCII 码字符后，我们肯定不能把辛苦得来的字符丢掉，但是我们并不知道用户程序什么时候会来索取字符，所以需要一个缓冲区存储字符，在 `keyboard.c` 放着一个简单的缓冲区：

```c
#define KB_INBUF_SIZE 4

typedef struct kb_inbuf {
  u8* p_head;
  u8* p_tail;
  int count;
  u8 buf[KB_INBUF_SIZE];
} kb_inbuf_t;

static kb_inbuf_t KB_INPUT = {
    .p_head = KB_INPUT.buf,
    .p_tail = KB_INPUT.buf,
    .count = 0,
};
```

这个数据结构本质上是一个队列，其中 `p_head` 指的是缓冲区的队首字符，`p_tail` 指的是缓冲区的队尾字符，`count` 是当前存储的字符数量，`buf` 是缓冲区。

需要注意的是让缓冲区满的时候所有添加的字符需要丢弃。

当有这么一个缓冲区，触发键盘中断将解析来的字符存放到缓冲区中，当有用户程序需要索取时将缓冲区的队首字符弹出交给用户程序，就完成了整个交互。
